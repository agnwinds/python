
/***********************************************************/
/** @file  photon_gen.c
 * @author ksl
 * @date   May, 2018
 *
 * @brief  Primary routines for creating photons for use in
 * the radiative transfer calculation.
 *
 ***********************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>


#include "atomic.h"
#include "python.h"



// These are external variables that are used to determine whether one needs to reinitialize
// by running xdefine_phot
double f1_old = 0;
double f2_old = 0;
int iwind_old = 0;

#define PRINT_OFF 0
#define PRINT_ON  1

/**********************************************************/
/**
 * @brief
 * the controlling routine for creating the underlying photon distribution.
 *
 * @param [out] PhotPtr  p   The structure where all photons are stored
 * @param [in] double  f1   The mininum frequency
 * @param [in] double  f2   The maximum frequency if a uniform distribution
 * @param [in] long  nphot_tot   The total number of photons that need to be generated to reach the total
 * luminosity, not necessarilly the number of photons which will be generated by the call to define_phot,
 * which instead is defined by NPHOT
 * @param [in] int  ioniz_or_final   0 -> this is for the wind ionization calculation,
 * 1-> it is for the final spectrum calculation
 * @param [in] int  iwind   A variable (see below) that controls the generation of phtons for the wind
 * @param [in] int  freq_sampling   If 0, generate photons over the full frequency range without banding,
 * else use banding
 * @return     Always returns 0
 *
 * @details
 * This routine oversees the generation of photons for the radiative transfer calculation.  Most of the actual
 * work is done in other routines, particularly xdefine_phot).  There can be multiple
 * radiation sources (e.g the star and a disk)
 *
 * There are two basic approaches to generating photons.  One can sample the entire wavelength interval in which
 * case all photons have the same weight, but photon frequencies are selected based on the the specific luminiosty.
 * In the banded approach, one defines bands in which photons are generated.  Specific numbers of photons are
 * are generated in each band, and within a band the photons are selected according the the specific luminosity,
 * but the weights of photons in different bands differ.
 * still used for detailed spectrum calculation. Which of this choices to use is controlled by freq_sampling
 * (The weights are established here)
 *
 * iwind is a variable that determines how or whether to create photons from the wind:
 * * -1-> Do not consider wind photons under any circumstances
 * * 0  ->Consider wind photons.  There is no need to recalculate the
 *   relative contribution to number of photons from the wind
 *   unless the frequencies have changed
 * * 1 -> Force a recalculation of the fraction of photons from the wind.
 *   This is necessary because after each ionization recalculation
 *   one needs to recalculate the flux fraction from the wind.
 *
 * ### Notes ###
 * @bug Is this correct, have subcycles been removed.
 *
 **********************************************************/

int
define_phot (p, f1, f2, nphot_tot, ioniz_or_final, iwind, freq_sampling)
     PhotPtr p;
     double f1, f2;
     long nphot_tot;
     int ioniz_or_final;
     int iwind;
     int freq_sampling;         // 0 --> old uniform approach, 1 --> minimum fractions ins various bins

{
  double natural_weight, weight;
  double ftot;
  int n;
  int iphot_start, nphot_rad, nphot_k;
  long nphot_tot_rad, nphot_tot_k;

  /* if we are generating nonradiative kpackets, then we need to subtract 
     off the fraction reserved for k-packets */
  if (geo.nonthermal && (geo.rt_mode == RT_MODE_MACRO) && (ioniz_or_final == 0))
  {
    nphot_k = (geo.frac_extra_kpkts * NPHOT);
    nphot_rad = NPHOT - nphot_k;
    nphot_tot_k = (geo.frac_extra_kpkts * nphot_tot);
    nphot_tot_rad = nphot_tot - nphot_tot_k;
  }
  else
  {
    nphot_rad = NPHOT;
    nphot_tot_rad = nphot_tot;
  }

  if (freq_sampling == 0)
  {                             /* Original approach, uniform sampling of entire wavelength interval,
                                   still used for detailed spectrum calculation */

    if (f1 != f1_old || f2 != f2_old || iwind != iwind_old)
    {                           // The reinitialization is required
      xdefine_phot (f1, f2, ioniz_or_final, iwind, PRINT_ON);
    }
    /* The weight of each photon is designed so that all of the photons add up to the
       luminosity of the photosphere.  This implies that photons must be generated in such
       a way that it mimics the energy distribution of the star. */

    geo.weight = (weight) = (geo.f_tot) / (nphot_tot_rad);

    for (n = 0; n < NPHOT; n++)
      p[n].path = -1.0;         /* SWM - Zero photon paths */

    xmake_phot (p, f1, f2, ioniz_or_final, iwind, weight, 0, nphot_rad);
  }
  else
  {                             /* Use banding, create photons with different weights in different wavelength
                                   bands.  This is used for the for ionization calculation where one wants to assure
                                   that you have "enough" photons at high energy */

    ftot = populate_bands (ioniz_or_final, iwind, &xband);

    for (n = 0; n < NPHOT; n++)
      p[n].path = -1.0;         /* SWM - Zero photon paths */

    /* Now generate the photons */

    iphot_start = 0;

    for (n = 0; n < xband.nbands; n++)
    {

      if (xband.nphot[n] > 0)
      {
        /* Reinitialization is required here always because we are changing
         * the frequencies around all the time */

        Log ("Defining photons for band %d...\n", n);

        xdefine_phot (xband.f1[n], xband.f2[n], ioniz_or_final, iwind, PRINT_ON);

        /* The weight of each photon is designed so that all of the photons add up to the
           luminosity of the photosphere.  This implies that photons must be generated in such
           a way that it mimics the energy distribution of the star. */

        geo.weight = (natural_weight) = (ftot) / (nphot_tot_rad);
        xband.weight[n] = weight = natural_weight * xband.nat_fraction[n] / xband.used_fraction[n];
        xmake_phot (p, xband.f1[n], xband.f2[n], ioniz_or_final, iwind, weight, iphot_start, xband.nphot[n]);

        iphot_start += xband.nphot[n];
      }
    }
  }

  /* deal with k-packets generated from nonradiative heating */
  if (geo.nonthermal && (geo.rt_mode == RT_MODE_MACRO) && (ioniz_or_final == 0))
  {
    /* calculate the non-radiative kpkt luminosity throughout the wind */
    geo.f_kpkt = get_kpkt_heating_f ();

    /* get the number of photons we have reserved in the photon structure */
    //nphot_k = geo.frac_extra_kpkts * NPHOT; 
    weight = (geo.f_kpkt) / (nphot_tot_k);

    /* throw an error if the k-packet weight is too high or low */
    if (weight > (100.0 * natural_weight) || weight < (0.01 * natural_weight))
    {
      Error ("define_phot: kpkt weight is %8.4e compared to characteristic photon weight %8.4e\n", weight, natural_weight);
    }
    if (sane_check (weight))
      Error ("define_phot: kpkt weight is %8.4e!\n", weight);

    Log ("!! xdefine_phot: total & banded kpkt luminosity due to non-radiative heating: %8.2e %8.2e \n", geo.heat_shock, geo.f_kpkt);


    /* generate the actual photons produced by the k-packets */
    photo_gen_kpkt (p, weight, iphot_start, nphot_k);
  }


  for (n = 0; n < NPHOT; n++)
  {
    p[n].w_orig = p[n].w;
    p[n].freq_orig = p[n].freq;
    p[n].origin_orig = p[n].origin;
    if (geo.reverb != REV_NONE && p[n].path < 0.0)      // SWM - Set path lengths for disk, star etc.
      simple_paths_gen_phot (&p[n]);
  }
  return (0);

}





/**********************************************************/
/**
 * @brief      Determine how many photons to allocate to each band
 *
 * @param [in] int  ioniz_or_final   indicate whether this is for an ioniz_or_final
 * @param [in] int  iwind   indicates where wind photons are created
 * @param [in,out] struct xbands *  band   is a pointer to the band sturctue where everythin is
 * @return     ftot which is the sum of the band limited luminosities
 *
 * @details
 * This routine determines how many photons to allocate to each
 * band.  Inputs determine a minimum fraction to allocate to each
 * band, but these need not sum to 1, and so the rest of the photons
 * are allocated naturally (that is to say) by the luminosities within
 * the bands.
 *
 * Much of the actual work is carried out in xdefine_phot.
 *
 * ### Notes ###
 *
 **********************************************************/

double
populate_bands (ioniz_or_final, iwind, band)
     int ioniz_or_final;
     int iwind;
     struct xbands *band;

{
  double ftot, frac_used, z;
  int n, nphot, most, nphot_rad;

  /* Get all of the band limited luminosities */
  ftot = 0.0;

  /* this is the number of photons minus the number reserved for k-packets */
  if (geo.nonthermal && (geo.rt_mode == RT_MODE_MACRO))
    nphot_rad = NPHOT - (geo.frac_extra_kpkts * NPHOT);
  else
    nphot_rad = NPHOT;

  for (n = 0; n < band->nbands; n++)    // Now get the band limited luminosities
  {
    if (band->f1[n] < band->f2[n])
    {
      xdefine_phot (band->f1[n], band->f2[n], ioniz_or_final, iwind, PRINT_OFF);

      ftot += band->flux[n] = geo.f_tot;
    }
    else
      band->flux[n] = 0.0;

    if (band->flux[n] == 0.0)
      band->min_fraction[n] = 0;
  }

/* So now we can distribute the photons among the different bands */

  frac_used = 0;

  for (n = 0; n < band->nbands; n++)
  {
    band->nat_fraction[n] = band->flux[n] / ftot;
    frac_used += band->min_fraction[n];
  }

  nphot = 0;
  z = 0;
  most = 0;


  for (n = 0; n < band->nbands; n++)
  {
    band->used_fraction[n] = band->min_fraction[n] + (1 - frac_used) * band->nat_fraction[n];
    nphot += band->nphot[n] = nphot_rad * band->used_fraction[n];
    if (band->used_fraction[n] > z)
    {
      z = band->used_fraction[n];
      most = n;
    }
  }

  /* Because of roundoff errors nphot may not sum to the desired value, namely NPHOT less kpackets.  
     So add a few more photons to the band with most photons already. It should only be a few, at most
     one photon for each band. */

  if (nphot < nphot_rad)
  {
    band->nphot[most] += (nphot_rad - nphot);
  }

  return (ftot);

}



/**********************************************************/
/**
 * @brief      calculates the band limited fluxes & luminosities, and prepares
 * for the producting of photons (by reinitializing the disk, among other things).
 *
 * @param [in] double  f1   The minimum freqeuncy
 * @param [in] double  f2   The maximum frequency
 * @param [in] int  ioniz_or_final   0 -> this is for the wind ionization calculation;
 * 1-> it is for the final spectrum calculation
 * @param [in] int  iwind   if 0, include wind photons; if 1 include wind photons and force a recalcuation of
 * ion denisities, if -1, ignore the possibility of wind photons
 * @return     Always returns 0
 *
 * @details
 * This is a routine that initilizes things.  It does not generate photons itself.
 *
 * The routine calls various other routines to calcuate the band limited luminosities
 * of various radiation sources (which is used in allocating how many photons to create
 * from each).  The results are stored in elements of the geo structure.
 *
 *
 *
 * ### Notes ###
 * @bug This routine is something of a kluge.  Information is passed back to the calling
 * routine through the geo structure, rather than a more obvious method.  The routine was
 * created when a banded approach was defined, but the whole section might be more obvious.
 *
 **********************************************************/

int
xdefine_phot (f1, f2, ioniz_or_final, iwind, print_mode)
     double f1, f2;
     int ioniz_or_final;
     int iwind;
     int print_mode;
{

  /* First determine if you need to reinitialize because the frequency boundaries are
     different than previously */

  geo.lum_star = geo.lum_disk = 0;      // bl luminosity is an input so it is not zeroed
  geo.f_star = geo.f_disk = geo.f_bl = 0;
  geo.f_kpkt = geo.f_matom = 0; //SS - kpkt and macro atom luminosities set to zero

  if (geo.star_radiation)
  {
    star_init (f1, f2, ioniz_or_final, &geo.f_star);
  }
  if (geo.disk_radiation)
  {

/* Note  -- disk_init not only calculates fluxes and luminosity for the disk.  It
calculates the boundaries of the various disk annulae depending on f1 and f2 */

    disk_init (geo.rstar, geo.diskrad, geo.mstar, geo.disk_mdot, f1, f2, ioniz_or_final, &geo.f_disk);
  }
  if (geo.bl_radiation)
  {
    bl_init (geo.lum_bl, geo.t_bl, f1, f2, ioniz_or_final, &geo.f_bl);
  }
  if (geo.agn_radiation)
  {
    agn_init (geo.r_agn, geo.lum_agn, geo.alpha_agn, f1, f2, ioniz_or_final, &geo.f_agn);
  }

/* The choices associated with iwind are
iwind = -1 	Don't generate any wind photons at all
         1  Create wind photons and force a reinitialization of the wind
         0  Create wind photons but remain open to the question of whether
		the wind needs to be reinitialized.  Initialization is forced
		in that case by init
*/

  if (iwind == -1)
    geo.f_wind = geo.lum_wind = 0.0;

  if (iwind == 1 || (iwind == 0))
  {                             /* Then find the luminosity and flux of the wind */
    geo.lum_wind = wind_luminosity (0.0, VERY_BIG);
    xxxpdfwind = 1;             // Turn on the portion of the line luminosity routine which creates pdfs
    geo.f_wind = wind_luminosity (f1, f2);
    xxxpdfwind = 0;             // Turn off the portion of the line luminosity routine which creates pdfs
  }

  /* Handle the initialization of emission via k-packets and macro atoms. SS */

  if (geo.matom_radiation)
  {
    /* JM 1408 -- only calculate macro atom emissivity if first cycle.
       Otherwise have restarted run and can use saved emissivities */
    /* This returns the specific luminosity
       in the spectral band of interest */
    if (geo.pcycle == 0)
    {
      geo.f_matom = get_matom_f (CALCULATE_MATOM_EMISSIVITIES);
    }
    else
      geo.f_matom = get_matom_f (USE_STORED_MATOM_EMISSIVITIES);


    geo.f_kpkt = get_kpkt_f (); /* This returns the specific luminosity
                                   in the spectral band of interest */

    matom_emiss_report ();      // function which logs the macro atom level emissivites
  }

  geo.f_tot = geo.f_star + geo.f_disk + geo.f_bl + geo.f_wind + geo.f_kpkt + geo.f_matom + geo.f_agn;
  geo.lum_tot = geo.lum_star + geo.lum_disk + geo.lum_bl + geo.lum_agn + geo.lum_wind;

  if (print_mode == PRINT_ON)
  {
    if (geo.adiabatic)
      Log ("!! xdefine_phot: heating & cooling  due to adiabatic processes:         %8.2e %8.2e \n", geo.heat_adiabatic,
           geo.cool_adiabatic);

    Log
      ("!! xdefine_phot: lum_tot %8.2e lum_star %8.2e lum_disk %8.2e lum_bl %8.2e lum_agn %8.2e lum_wind %8.2e\n",
       geo.lum_tot, geo.lum_star, geo.lum_disk, geo.lum_bl, geo.lum_agn, geo.lum_wind);

    Log
      ("!! xdefine_phot:   f_tot %8.2e   f_star %8.2e   f_disk %8.2e   f_bl %8.2e   f_agn %8.2e   f_wind %8.2e   f_matom %8.2e   f_kpkt %8.2e \n",
       geo.f_tot, geo.f_star, geo.f_disk, geo.f_bl, geo.f_agn, geo.f_wind, geo.f_matom, geo.f_kpkt);

    Log
      ("!! xdefine_phot: wind ff %8.2e       fb %8.2e   lines  %8.2e  for freq %8.2e %8.2e\n",
       geo.lum_ff, geo.lum_rr, geo.lum_lines, f1, f2);
    Log
      ("!! xdefine_phot: star  tstar  %8.2e   %8.2e   lum_star %8.2e %8.2e  %8.2e \n",
       geo.tstar, geo.tstar_init, geo.lum_star, geo.lum_star_init, geo.lum_star_back);
    Log
      ("!! xdefine_phot: disk                               lum_disk %8.2e %8.2e  %8.2e \n",
       geo.lum_disk, geo.lum_disk_init, geo.lum_disk_back);
  }

  /* Store the 3 variables that have to remain the same to avoid reinitialization */

  f1_old = f1;
  f2_old = f2;
  iwind_old = iwind;
  return (0);

}





/**********************************************************/
/**
 * @brief      just makes photons (in a particular wavelength range for
 * all radiation sources)
 *
 * @param [out] PhotPtr  p   The entire photon structure
 * @param [in] double  f1   The minimum frequency for generating photons
 * @param [in] double  f2   The maximum frequency for generating photons
 * @param [in] int  ioniz_or_final   A flag indicating whether this if for an ionization or detailed
 * spectral cycle (Used to determine what underlying spectrum, e.g bb or detailed models) to sample
 * @param [in] int  iwind   A flag indicating whether or not to generate any wind photons.
 * @param [in] double  weight   The weight of photons to generate
 * @param [in] int  iphot_start   The position in the photon structure to start storing photons
 * @param [in] int  nphotons   The number of photons to generate
 * @return     Always returns 0
 *
 * @details
 * make_phot controls the actual generation of photons.  All of the initializations should
 * have been done previously (xdefine_phot).  xmake_phot cycles through the various possible
 * sources of the wind, including for example, the disk, the central object, and the
 * wind, and creates photons for each, using the ratio of the band limited luminosites to the
 * total band limited luminosity to determine how many photons to select from each source.
 *
 * ### Notes ###
 *
 **********************************************************/

int
xmake_phot (p, f1, f2, ioniz_or_final, iwind, weight, iphot_start, nphotons)
     PhotPtr p;
     double f1, f2;
     int ioniz_or_final;
     int iwind;
     double weight;
     int iphot_start;           //The place to begin putting photons in the photon structure in this call
     int nphotons;              //The total number of photons to generate in this call
{

  int nphot, nn;
  int nstar, nbl, nwind, ndisk, nmatom, nagn, nkpkt;
  double agn_f1;

  nstar = nbl = nwind = ndisk = 0;
  nagn = nkpkt = nmatom = 0;

  if (geo.star_radiation)
  {
    nstar = geo.f_star / geo.f_tot * nphotons;
  }
  if (geo.bl_radiation)
  {
    nbl = geo.f_bl / geo.f_tot * nphotons;
  }
  if (iwind >= 0)
  {
    nwind = geo.f_wind / geo.f_tot * nphotons;
  }
  if (geo.disk_radiation)
  {
    ndisk = geo.f_disk / geo.f_tot * nphotons;  /* Ensure that nphot photons are created */
  }
  if (geo.agn_radiation)
  {
    nagn = geo.f_agn / geo.f_tot * nphotons;    /* Ensure that nphot photons are created */
  }
  if (geo.matom_radiation || geo.nonthermal)
  {
    nkpkt = geo.f_kpkt / geo.f_tot * nphotons;

    if (geo.matom_radiation)
      nmatom = geo.f_matom / geo.f_tot * nphotons;
  }


  nphot = ndisk + nwind + nbl + nstar + nagn + nkpkt + nmatom;

  if (nphot < nphotons)
  {
    if (ndisk > 0)
      ndisk += (nphotons - nphot);
    else if (nwind > 0)
      nwind += (nphotons - nphot);
    else if (nbl > 0)
      nbl += (nphotons - nphot);
    else if (nagn > 0)
      nagn += (nphotons - nphot);
    else
      nstar += (nphotons - nphot);
  }


  Log
    ("photon_gen: band %6.2e to %6.2e weight %6.2e nphotons %8d ndisk %7d nwind %7d nstar %7d npow %d \n",
     f1, f2, weight, nphotons, ndisk, nwind, nstar, nagn);

  /* Generate photons from the star, the bl, the wind and then from the disk */
  /* Now adding generation from kpkts and macro atoms too (SS June 04) */


  if (geo.star_radiation)
  {
    nphot = nstar;
    if (nphot > 0)
    {
      if (ioniz_or_final == 1)
        photo_gen_star (p, geo.rstar, geo.tstar, weight, f1, f2, geo.star_spectype, iphot_start, nphot);
      else
        photo_gen_star (p, geo.rstar, geo.tstar, weight, f1, f2, geo.star_ion_spectype, iphot_start, nphot);
    }
    iphot_start += nphot;
  }
  if (geo.bl_radiation)
  {
    nphot = nbl;

    if (nphot > 0)
    {
      if (ioniz_or_final == 1)
        photo_gen_star (p, geo.rstar, geo.t_bl, weight, f1, f2, geo.bl_spectype, iphot_start, nphot);
      else
        photo_gen_star (p, geo.rstar, geo.t_bl, weight, f1, f2, geo.bl_ion_spectype, iphot_start, nphot);
/* Reassign the photon type since we are actually using the same routine as for generating
stellar photons */
      nn = 0;
      while (nn < nphot)
      {
        p[iphot_start + nn].origin = PTYPE_BL;
        nn++;
      }
    }
    iphot_start += nphot;
  }

/* Generate the wind photons */

  if (iwind >= 0)
  {
    nphot = nwind;
    if (nphot > 0)
      photo_gen_wind (p, weight, f1, f2, iphot_start, nphot);
    iphot_start += nphot;
  }

/* Generate the disk photons */

  if (geo.disk_radiation)
  {
    nphot = ndisk;
    if (nphot > 0)
    {
      if (ioniz_or_final == 1)
        photo_gen_disk (p, weight, f1, f2, geo.disk_spectype, iphot_start, nphot);
      else
        photo_gen_disk (p, weight, f1, f2, geo.disk_ion_spectype, iphot_start, nphot);
    }
    iphot_start += nphot;
  }

  /* Generate the agn photons */

  if (geo.agn_radiation)
  {
    nphot = nagn;
    if (nphot > 0)
    {
      /* JM 1502 -- lines to add a low frequency power law cutoff. accessible
         only in advanced mode */
      if (geo.pl_low_cutoff != 0.0 && geo.pl_low_cutoff > f1)
        agn_f1 = geo.pl_low_cutoff;

      /* error condition if user specifies power law cutoff below that hardwired in
         ionization cycles */
      else if (geo.pl_low_cutoff > f1 && ioniz_or_final == 0)
      {
        Error ("photo_gen_agn: power_law low f cutoff (%8.4e) is lower than hardwired minimum frequency (%8.4e)\n", geo.pl_low_cutoff, f1);
        agn_f1 = f1;
      }
      else
        agn_f1 = f1;


      if (ioniz_or_final == 1)
        photo_gen_agn (p, geo.r_agn, geo.alpha_agn, weight, agn_f1, f2, geo.agn_spectype, iphot_start, nphot);
      else
        photo_gen_agn (p, geo.r_agn, geo.alpha_agn, weight, agn_f1, f2, geo.agn_ion_spectype, iphot_start, nphot);
    }
    iphot_start += nphot;
  }

  /* Now do macro atoms and k-packets. SS June 04 */

  if (geo.matom_radiation)
  {
    nphot = nkpkt;
    if (nphot > 0)
    {
      if (ioniz_or_final == 0)
      {
        Error ("xmake_phot: generating photons by k-packets when performing ionization cycle without shock heating. Abort.\n");
        exit (0);               //The code shouldn't be doing this - something has gone wrong somewhere. (SS June 04)
      }
      else
      {
        photo_gen_kpkt (p, weight, iphot_start, nphot);
      }
    }
    iphot_start += nphot;

    nphot = nmatom;
    if (nphot > 0)
    {
      if (ioniz_or_final == 0)
      {
        Error ("xmake_phot: generating photons by macro atoms when performing ionization cycle. Abort.\n");
        Exit (0);               //The code shouldn't be doing this - something has gone wrong somewhere. (SS June 04)
      }
      else
      {
        photo_gen_matom (p, weight, iphot_start, nphot);
      }
    }
    iphot_start += nphot;
  }

  return (0);
}






/**********************************************************/
/**
 * @brief      (r, tstar, freqmin, freqmax, ioniz_or_final, f)
 *
 * @param [in] double  freqmin   The minimum freqency for the band
 * @param [in] double  freqmax   The maximum freqency for the band
 * @param [in out] int  ioniz_or_final  A flag indicating whether this is for
 * an ionization cycle or a detailed spectrum cycle
 * @param [out] double *  f   The baand limited luminosity of the star
 * @return     Always returns 0
 *
 * @details
 * This routine calculates the luminosity of the star and the luminosity within
 * the frequency boundaries.
 *
 * ### Notes ###
 * The routine allows for backscattering of light onto the star
 * assuming the user has opted to include this in the determination
 * of the effective temperature of the star
 *
 **********************************************************/

int
star_init (freqmin, freqmax, ioniz_or_final, f)
     double freqmin, freqmax, *f;
     int ioniz_or_final;
{
  double r, tstar, log_g;
  double emit, emittance_bb (), emittance_continuum ();
  int spectype;

  log_g = geo.gstar = log10 (G * geo.mstar / (geo.rstar * geo.rstar));
  r = geo.rstar;

  tstar = geo.tstar = geo.tstar_init;
  geo.lum_star = geo.lum_star_init;

  if (geo.absorb_reflect == BACK_RAD_ABSORB_AND_HEAT && geo.lum_star_back > 0)
  {
    geo.lum_star = geo.lum_star + geo.lum_star_back;
    tstar = geo.tstar = pow (geo.lum_star / (4 * PI * STEFAN_BOLTZMANN * r * r), 0.25);
  }


  if (ioniz_or_final == 1)
    spectype = geo.star_spectype;       /* type for final spectrum */
  else
    spectype = geo.star_ion_spectype;   /*type for ionization calculation */

  if (spectype >= 0)
  {
    emit = emittance_continuum (spectype, freqmin, freqmax, tstar, log_g);
  }
  else
  {
    emit = emittance_bb (freqmin, freqmax, tstar);
  }

  *f = emit;                    // Calculate the surface flux between freqmin and freqmax
  *f *= (4. * PI * r * r);


  return (0);

}

/* Generate nphot photons from the star in the frequency interval f1 to f2 */


/**********************************************************/
/**
 * @brief
 * Generate nphot photons from the star in the frequency interval f1 to f2
 *
 * @param [out] PhotPtr  p   The entire photon structure
 * @param [in] double  r   The radiius at which to generate photons
 * @param [in] double  t   The effective temperature of the stat
 * @param [in] double  weight   The weight of photons to generate
 * @param [in] double  f1   The minimum frequencey
 * @param [in] double  f2   The maximum frequencey
 * @param [in] int  spectype   The type of spectrum (bb or spectral model) to use in generating photons
 * @param [in] int  istart   The positions in the photon structure where the first photons will be stored
 * @param [in] int  nphot   The nubmer of photons to generate
 * @return     Always returns 0
 *
 * @details
 * The routine generates photons emergying from a sphere.  It uses
 * randvcos to determine the direction of the photon.
 *
 * ### Notes ###
 * This routine is also used in generating photons from a boundary layer
 *
 * The routine allows for the possibility that part of the star will be
 * covered by a vertically extended disk and avoids generating photons there.
 *
 **********************************************************/

int
photo_gen_star (p, r, t, weight, f1, f2, spectype, istart, nphot)
     PhotPtr p;
     double r, t, weight;
     double f1, f2;             /* The freqency mininimum and maximum if a uniform distribution is selected */
     int spectype;              /*The spectrum type to generate: 0 is bb, 1 (or in fact anything but 0)
                                   is uniform in frequency space */
     int istart, nphot;         /* Respecitively the starting point in p and the number of photons to generate */
{
  double freqmin, freqmax;
  int i, iend;
  if ((iend = istart + nphot) > NPHOT)
  {
    Error ("photo_gen_star: iend %d > NPHOT %d\n", iend, NPHOT);
    Exit (0);
  }
  if (f2 < f1)
  {
    Error ("photo_gen_star: Cannot generate photons if freqmax %g < freqmin %g\n", f2, f1);
  }
  Log_silent ("photo_gen_star creates nphot %5d photons from %5d to %5d \n", nphot, istart, iend);
  freqmin = f1;
  freqmax = f2;
  r = (1. + EPSILON) * r;       /* Generate photons just outside the photosphere */
  for (i = istart; i < iend; i++)
  {
    p[i].origin = PTYPE_STAR;   // For BL photons this is corrected in photon_gen
    p[i].w = weight;
    p[i].istat = p[i].nscat = p[i].nrscat = 0;
    p[i].grid = 0;
    p[i].tau = 0.0;
    p[i].nres = -1;             // It's a continuum photon
    p[i].nnscat = 1;

    if (spectype == SPECTYPE_BB)
    {
      p[i].freq = planck (t, freqmin, freqmax);
    }
    else if (spectype == SPECTYPE_UNIFORM)
    {                           /* Kurucz spectrum */
      /*Produce a uniform distribution of frequencies */
      p[i].freq = random_number (freqmin, freqmax);     //Generate a random frequency - this will exclude freqmin,freqmax.

    }
    else
    {
      p[i].freq = one_continuum (spectype, t, geo.gstar, freqmin, freqmax);
    }

    if (p[i].freq < freqmin || freqmax < p[i].freq)
    {
      Error_silent ("photo_gen_star: phot no. %d freq %g out of range %g %g\n", i, p[i].freq, freqmin, freqmax);
    }

    randvec (p[i].x, r);

    if (geo.disk_type == DISK_VERTICALLY_EXTENDED)
    {
      while (fabs (p[i].x[2]) < zdisk (r))
      {
        randvec (p[i].x, r);
      }


      if (fabs (p[i].x[2]) < zdisk (r))
      {
        Error ("Photon_gen: stellar photon %d in disk %g %g %g %g %g\n", i, p[i].x[0], p[i].x[1], p[i].x[2], zdisk (r), r);
        Exit (0);
      }
    }

    randvcos (p[i].lmn, p[i].x);
  }
  return (0);
}


/* THE NEXT FEW ROUTINES PERTAIN ONLY TO THE DISK */


#define STEPS 100000



/**********************************************************/
/**
 * @brief      calculates the total luminosity and the luminosity between freqqmin and freqmax
 * 	of the disk.  More importantly  divides the disk into annulae such that each
 * 	annulus contributes and equal amount to the lumionosity of the disk (within the frequency
 * 	limits).  Thus  initializes the structure "disk".
 *
 * @param [in] double  rmin   The minimum radius of the disk
 * @param [in] double  rmax   The maximum radius of the disk
 * @param [in] double  m   mass of central object
 * @param [in] double  mdot   mass accretion rate
 * @param [in] double  freqmin   The minimum frequency
 * @param [in] double  freqmax   The maximum frequency
 * @param [in] int  ioniz_or_final   A flag indicating whether this is an ionization or
 * a detailed spectral cycle (used to determine the spectral type to use)
 * @param [out] double *  ftot   The band limited luminosity in the freqency interval
 * @return     the total luminosity of the disk
 *
 * @details
 * This routine assumes the temperature distribution for the disk is
 * that of a simple Shakura-Sunyaev disk, and uses this to determine
 * the band limited luminosity of the disk.  Additionally, it divides
 * the disk in the rings of the same band-limited luminosity, so that
 * equal numbers of photons can be generated from each ring.  (The
 * reason the disk has to be initilaized mulitple times is because
 * the rings are different for different freqency intervals.)
 *
 * ### Notes ###
 * The information needed to generate photons from the disk is stored
 * in the disk structure.
 * The positional parameters x and v are at the edge of the ring,
 * but many of the other parameters (like temperature) are at the mid point.
 *
 *
 **********************************************************/

double
disk_init (rmin, rmax, m, mdot, freqmin, freqmax, ioniz_or_final, ftot)
     double rmin, rmax, m, mdot, freqmin, freqmax, *ftot;
     int ioniz_or_final;
{
  double t, tref, teff (), tdisk ();
  double log_g, gref, geff (), gdisk ();
  double dr, r;
  double logdr, logrmin, logrmax, logr;
  double f, ltot;
  double q1;
  int nrings, i, icheck;
  int spectype;
  double emit, emittance_bb (), emittance_continuum ();

  /* Calculate the reference temperature and luminosity of the disk */
  tref = tdisk (m, mdot, rmin);


  gref = gdisk (m, mdot, rmin);


  /* Now compute the apparent luminosity of the disk.  This is not actually used
     to determine how annulae are set up.  It is just used to populate geo.ltot.
     It can change if photons hitting the disk are allowed to raise the temperature
   */

  logrmax = log (rmax);
  logrmin = log (rmin);
  logdr = (logrmax - logrmin) / STEPS;

  for (nrings = 0; nrings < NRINGS; nrings++)   //Initialise the structure
  {
    disk.nphot[nrings] = 0;
    disk.nphot[nrings] = 0;
    disk.r[nrings] = 0;
    disk.t[nrings] = 0;
    disk.nhit[nrings] = 0;
    disk.heat[nrings] = 0;
    disk.ave_freq[nrings] = 0;
    disk.w[nrings] = 0;
    disk.t_hit[nrings] = 0;
  }




  ltot = 0;

  for (logr = logrmin; logr < logrmax; logr += logdr)
  {
    r = exp (logr);
    dr = exp (logr + logdr) - r;
    t = teff (tref, (r + 0.5 * dr) / rmin);
    ltot += t * t * t * t * (2. * r + dr) * dr;
  }
  geo.lum_disk_init = ltot *= 2. * STEFAN_BOLTZMANN * PI;


  /* Now establish the type of spectrum to create */

  if (ioniz_or_final == 1)
    spectype = geo.disk_spectype;       /* type for final spectrum */
  else
    spectype = geo.disk_ion_spectype;   /*type for ionization calculation */

/* Next compute the band limited luminosity ftot */

/* The area of an annulus is  PI*((r+dr)**2-r**2) = PI * (2. * r +dr) * dr.
   The extra factor of two arises because the disk radiates from both of its sides.
   */

  q1 = 2. * PI;

  (*ftot) = 0;
  icheck = 0;


  for (logr = logrmin; logr < logrmax; logr += logdr)
  {
    r = exp (logr);
    dr = exp (logr + logdr) - r;
    t = teff (tref, (r + 0.5 * dr) / rmin);
    log_g = log10 (geff (gref, (r + 0.5 * dr) / rmin));

    if (spectype > -1)
    {                           // emittance from a continuum model
      emit = emittance_continuum (spectype, freqmin, freqmax, t, log_g);
    }
    else
    {
      emit = emittance_bb (freqmin, freqmax, t);

    }
    (*ftot) += emit * (2. * r + dr) * dr;
  }

  (*ftot) *= q1;



  /* If *ftot is 0 in this energy range then all the photons come elsewhere, e. g. the star or BL  */

  if ((*ftot) < EPSILON)
  {
    Log_silent ("disk_init: Warning! Disk does not radiate enough to matter in this wavelength range\n");
    return (ltot);
  }

  /* Now find the boundaries of the each annulus, which depends on the band limited flux.
     Note that disk.v is calculated at the boundaries, because vdisk() interporlates on
     the actual radius. */

  disk.r[0] = rmin;
  disk.v[0] = sqrt (G * geo.mstar / rmin);
  nrings = 1;
  f = 0;

  i = 0;
  for (logr = logrmin; logr < logrmax; logr += logdr)
  {
    r = exp (logr);
    dr = exp (logr + logdr) - r;
    t = teff (tref, (r + 0.5 * dr) / rmin);
    log_g = log10 (geff (gref, (r + 0.5 * dr) / rmin));

    if (spectype > -1)
    {                           // continuum emittance
      emit = emittance_continuum (spectype, freqmin, freqmax, t, log_g);
    }
    else
    {
      emit = emittance_bb (freqmin, freqmax, t);
    }

    f += q1 * emit * (2. * r + dr) * dr;
    i++;
    /* EPSILON to assure that roundoffs don't affect result of if statement */
    if (f / (*ftot) * (NRINGS - 1) >= nrings)
    {
      if (r <= disk.r[nrings - 1])      //If the radius we have reached is smaller than or equal to the last assigned radius - we make a tiny annulus
      {
        r = disk.r[nrings - 1] * (1. + 1.e-10);
      }
      disk.r[nrings] = r;
      disk.v[nrings] = sqrt (G * geo.mstar / r);
      nrings++;
      if (nrings >= NRINGS)
      {
//        Error_silent ("disk_init: Got to ftot %e at r %e < rmax %e. OK if freqs are high\n", f, r, rmax);             Not *really* an error, the error below deals with a *real* problem.
        break;
      }
    }
  }
  if (nrings < NRINGS - 1)
  {
    Error ("error: disk_init: Integration on setting r boundaries got %d nrings instead of %d\n", nrings, NRINGS - 1);
    Exit (0);
  }


  disk.r[NRINGS - 1] = exp (logrmax);
  disk.v[NRINGS - 1] = sqrt (G * geo.mstar / disk.r[NRINGS - 1]);


  /* Now calculate the temperature and gravity of the annulae */

  for (nrings = 0; nrings < NRINGS - 1; nrings++)
  {
    r = 0.5 * (disk.r[nrings + 1] + disk.r[nrings]);
    disk.t[nrings] = teff (tref, r / rmin);
    disk.g[nrings] = geff (gref, r / rmin);
  }

  /* Wrap up by zerrowing other parameters */
  for (nrings = 0; nrings < NRINGS; nrings++)
  {
    disk.nphot[nrings] = 0;
    disk.nhit[nrings] = 0;
    disk.heat[nrings] = 0;
    disk.ave_freq[nrings] = 0;
    disk.w[nrings] = 0;
    disk.t_hit[nrings] = 0;
  }

  geo.lum_disk = ltot;
  return (ltot);
}





/**********************************************************/
/**
 * @brief      Generate disk photons
 *
 * @param [out] PhotPtr  p   The entire photon structure
 * @param [in] double  weight   The weight of photons to generate
 * @param [in] double  f1   The minimum frequency
 * @param [in] double  f2   The maxnimum frequency
 * @param [in] int  spectype   The spectrum type to generate: 0 is bb
 * @param [in] int  istart   The starting point in p for generating photons
 * @param [in] int  nphot   The number of photons to generate
 * @return     Always returns 0
 *
 * @details
 *
 * ### Notes ###
 *
 **********************************************************/

int
photo_gen_disk (p, weight, f1, f2, spectype, istart, nphot)
     PhotPtr p;
     double weight;
     double f1, f2;
     int spectype;
     int istart, nphot;
{

  double freqmin, freqmax;
  int i, iend;
  double planck ();
  double t, r, z, theta, phi;
  int nring;
  double north[3], v[3];
  if ((iend = istart + nphot) > NPHOT)
  {
    Error ("photo_gen_disk: iend %d > NPHOT %d\n", iend, NPHOT);
    Exit (0);
  }
  if (f2 < f1)
  {
    Error ("photo_gen_disk: Can't do anything if f2 %g < f1 %g\n", f2, f1);
    Exit (0);
  }
  Log_silent ("photo_gen_disk creates nphot %5d photons from %5d to %5d \n", nphot, istart, iend);
  freqmin = f1;
  freqmax = f2;
  for (i = istart; i < iend; i++)
  {
    p[i].origin = PTYPE_DISK;   // identify this as a disk photon
    p[i].w = weight;
    p[i].istat = p[i].nscat = p[i].nrscat = 0;
    p[i].tau = 0;
    p[i].nres = -1;             // It's a continuum photon
    p[i].nnscat = 1;
    if (geo.reverb_disk == REV_DISK_UNCORRELATED)
      p[i].path = 0;            //If we're assuming disk photons are uncorrelated, leave them at 0

/* The ring boundaries are defined so that an equal number of photons are
 * generated in each ring.  Howver, there is a possibility that the number
 * of photons to be generated is small, and therefore we, we still randomly
 * generate photon.  04march -- ksl
 */

    nring = random_number (0.0, 1.0) * (NRINGS - 1);


    if ((nring < 0) || (nring > NRINGS - 2))
    {
      Error ("photon_gen: photon launch out of bounds. nring = %d\n", nring);
      Exit (0);
    }

    disk.nphot[nring]++;

/* The next line is really valid only if dr is small.  Otherwise one
 * should account for the area.  But haven't fixed this yet ?? 04Dec
 */

    r = disk.r[nring] + (disk.r[nring + 1] - disk.r[nring]) * random_number (0.0, 1.0);

    /* Generate a photon in the plane of the disk a distance r */


    phi = 2. * PI * random_number (0.0, 1.0);

    p[i].x[0] = r * cos (phi);
    p[i].x[1] = r * sin (phi);


    z = 0.0;
    north[0] = 0;
    north[1] = 0;
    north[2] = 1;

    /* Correct photon direction of a vertically extended disk
     */

    if (geo.disk_type == DISK_VERTICALLY_EXTENDED)
    {
      if (r == 0)
        theta = 0;
      else
      {
        z = zdisk (r);
        theta = atan ((zdisk (r * (1. + EPSILON)) - z) / (EPSILON * r));
      }
      north[0] = (-cos (phi) * sin (theta));
      north[1] = (-sin (phi) * sin (theta));
      north[2] = cos (theta);

    }

    if (random_number (-0.5, 0.5) > 0.0)        //Get a uniform random number brtween -0.5 and 0.5- use sign to toss a coin.
    {                           /* Then the photon emerges in the upper hemisphere */
      p[i].x[2] = (z + EPSILON);
    }
    else
    {
      p[i].x[2] = -(z + EPSILON);
      north[2] *= -1;
    }
    randvcos (p[i].lmn, north);

    /* Note that the next bit of code is almost duplicated in photo_gen_star.  It's
     * possilbe this should be collected into a single routine   080518 -ksl
     */

    if (spectype == SPECTYPE_BB)
    {
      t = disk.t[nring];
      p[i].freq = planck (t, freqmin, freqmax);
    }
    else if (spectype == SPECTYPE_UNIFORM)
    {                           //Produce a uniform distribution of frequencies

      p[i].freq = random_number (freqmin, freqmax);     //Get a random frequency between fmin and fmax (exluding the ends)
    }

    else
    {                           /* Then we will use a model which was read in */
      p[i].freq = one_continuum (spectype, disk.t[nring], log10 (disk.g[nring]), freqmin, freqmax);
    }

    if (p[i].freq < freqmin || freqmax < p[i].freq)
    {
      Error_silent ("photo_gen_disk: phot no. %d freq %g out of range %g %g\n", i, p[i].freq, freqmin, freqmax);
    }
    /* Now Doppler shift this. Use convention of dividing when going from rest
       to moving frame */

    vdisk (p[i].x, v);
    p[i].freq /= (1. - dot (v, p[i].lmn) / C);

  }


  return (0);
}




/**********************************************************/
/**
 * @brief      write information about the disk to a file
 *
 * @param [in out] char  filename[]   The name of the file
 * @param [in out] char  mode[]   A switch to determine whther to
 * write a new file or append to an existing file
 * @return     Always returns 0
 *
 * @details
 * The routine normal writes the disk.diag file.  It provides
 * infomration not only about the rings used, but also about
 * the number of photons that hit each ring,
 *
 * ### Notes ###
 *
 * This routine is now well-named
 *
 **********************************************************/

int
phot_gen_sum (filename, mode)
     char filename[], mode[];
{
  FILE *fopen (), *ptr;
  int n;
  double x;
  if (mode[0] == 'a')
    ptr = fopen (filename, "a");
  else
    ptr = fopen (filename, "w");
  fprintf (ptr, "Ring     r      t      nphot   dN/dr\n");
  for (n = 0; n < NRINGS; n++)
  {
    if (n == 0)
      x = 0;
    else
      x = disk.nphot[n] / (disk.r[n] - disk.r[n - 1]);
    fprintf (ptr, "%d %8.2e %8.2e %8d %8.2e %8d\n", n, disk.r[n], disk.t[n], disk.nphot[n], x, disk.nhit[n]);
  }

  fclose (ptr);
  return (0);
}

/* THESE ROUTINES ARE FOR THE BOUNDARY LAYER */




/**********************************************************/
/**
 * @brief      calculate parameters need to intialize the boundary layer (namely
 * the band-liminted luminoisity)
 *
 * @param [in out] double  lum_bl   The desired luminosity for the boundary layaer
 * @param [in out] double  t_bl   The temperature
 * @param [in out] double  freqmin   The minimum freqency in the band
 * @param [in out] double  freqmax   The maximum freqency in the band
 * @param [in out] int  ioniz_or_final   The spectral type to use in the calucation
 * (NOT USED) but see below
 * @param [in out] double *  f   The band limited luminosity
 * @return   The total luminosity
 *
 * The only thing that is actually calculated here is f, the luminosity
 * 	within the frequency range that is specified.
 *
 * @details
 * This routine calculates the  luminosity of the bl within the frequency boundaries.
 * BB functions are assumed.  It was derived from the same routine for a star,
 * but here we have assumed that the temperature and the luminosity are known
 *
 * ### Notes ###
 * @bug  At present bl_init assumes a BB regardless of the spectrum.
 * This is not really correct, and is different for what is done in initializing
 * the star
 *
 * 0703 - ksl - This is rather an odd little routine.  As noted all that is
 * calculated is f.  ioniz_or_final is not used, and lum_bl which
 * is returned is only the luminosity that was passed.
 *
 **********************************************************/

double
bl_init (lum_bl, t_bl, freqmin, freqmax, ioniz_or_final, f)
     double lum_bl, t_bl, freqmin, freqmax, *f;
     int ioniz_or_final;
{
  double q1;
  double integ_planck_d ();
  double alphamin, alphamax;

  q1 = 2. * PI * (BOLTZMANN * BOLTZMANN * BOLTZMANN * BOLTZMANN) / (H * H * H * C * C);
  alphamin = H * freqmin / (BOLTZMANN * t_bl);
  alphamax = H * freqmax / (BOLTZMANN * t_bl);
  *f = q1 * integ_planck_d (alphamin, alphamax) * lum_bl / STEFAN_BOLTZMANN;
  return (lum_bl);
}




/**********************************************************/
/**
 * @brief
 * Perform some simple checks on the photon distribution just produced.
 *
 * @param [in] PhotPtr  p  The photon structure
 * @param [in] double  freqmin   The minimum fequency that was used to generate the photons
 * @param [in] double  freqmax   The maximum fequency that was used to generate the photons
 * @param [in] char *  comment   A comment that accompanies this particular call
 * @return     Always returns 0
 *
 * @details
 * The routine checks photons to see if they are "reasonable".  The checks mostly have to
 * do with the frequency of the photons.   
 *
 * The program will exit is too many photons fail the
 * checks. The number of photons that are permitted to "fail" depends on the
 * total number of photons in a flight of photons
 *
 * ### Notes ###
 *
 * In checking for the reasonableness of the frequencies, their is a
 * fairly generous allowance for doppler shifts in the wind.
 *
 * The frequency limits are not enforced on photons that have excited
 * macro-atoms.
 *
 * The routine also determines the calculates some features of the
 * photon distribution, specifically having to do with the ionizing
 * photons.  It is not entirely clear why this is where this is done
 *
 * 181009 - ksl - Previously, this routine caused Python to exit 
 * if phtoon_checks produced more than a small number of errors. I
 * have removed this exterme measure but that toes not mean that
 * photon checks should be igrnored.
 *
 **********************************************************/

int
photon_checks (p, freqmin, freqmax, comment)
     char *comment;
     PhotPtr p;
     double freqmin, freqmax;
{
  int nnn, nn;
  int nlabel;
//OLD  int max_errors;
  geo.n_ioniz = 0;
  geo.cool_tot_ioniz = 0.0;
  nnn = 0;
  nlabel = 0;
//OLD  max_errors = 100;
//OLD  if (max_errors < 1e-5 * NPHOT)
//OLD  {
//OLD    max_errors = 1e-5 * NPHOT;
//OLD  }

  /* Next two lines are to allow for fact that photons generated in
   * a frequency range may be Doppler shifted out of that range, especially
   * if they are disk photons generated right up against one of the frequency
   * limits
   * 04aug--ksl-increased limit from 0.02 to 0.03, e.g from 6000 km/s to 9000 km/s
   * 11apr--NSH-decreased freqmin to 0.4, to take account of double redshifted photons.
   * shift.
   */

  Debug ("photon_checks: %s\n", comment);

  freqmax *= (1.8);
  freqmin *= (0.6);
  for (nn = 0; nn < NPHOT; nn++)
  {
    p[nn].np = nn;
    if (H * p[nn].freq > ion[0].ip)
    {
      geo.cool_tot_ioniz += p[nn].w;
      geo.n_ioniz += p[nn].w / (H * p[nn].freq);
    }
    if (sane_check (p[nn].freq) != 0 || sane_check (p[nn].w))
    {
      if (nlabel == 0)
      {
        Error ("photon_checks:   nphot  origin  freq     freqmin    freqmax\n");
        nlabel++;
      }
      Error ("photon_checks: %id %5d %5d %10.4e %10.4e %10.4e freq out of range\n", nn, p[nn].origin, p[nn].nres, p[nn].freq, freqmin,
             freqmax);
      p[nn].freq = freqmax;
      nnn++;
    }
    if (p[nn].origin < 10 && (p[nn].freq < freqmin || freqmax < p[nn].freq))
    {
      if (nlabel == 0)
      {
        Error ("photon_checks:   nphot  origin  nres  freq     freqmin    freqmax\n");
        nlabel++;
      }
      Error ("photon_checks: %id %5d %5d %10.4e %10.4e %10.4e freq out of range\n", nn, p[nn].origin, p[nn].nres, p[nn].freq, freqmin,
             freqmax);
      p[nn].freq = freqmax;
      nnn++;
    }
  }

  if (nnn == 0)
    Debug ("photon_checks: All photons passed checks successfully\n");
  else
  {
    Log ("photon_checks: %d of %d or %e per cent of photons failed checks\n", nnn, NPHOT, nnn * 100. / NPHOT);
  }

//OLD  if (nnn > max_errors)
//OLD  {
//OLD    error_summary ("Exiting because too many bad photons generated");
//OLD Avoide the exit      Exit (0);
//OLD  }


  return (0);
}
